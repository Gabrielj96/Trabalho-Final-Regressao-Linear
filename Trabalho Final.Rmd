---
title: "R Notebook"
output: html_notebook
---

```{r}
library(dplyr)
library(corrplot)
library(car)
options(scipen = 999)
```

# **1. Capa**

![](lightweight_mmm.png)

## **Análise de Regressão Linear Múltipla: relações entre publicidade e receita**

Gabriel Augusto

Bruce Percílio

Fernando

# **2. Resumo**

# **3. Introdução**

A estatística está cada vez mais presente no mercado de publicidade, cada ano surgem novas ténicas, métodos e experimentos para impulsionar os resultados dos négocios.

Sendo assim, o presente trabalho tem como objetivo entender a relação entre variáveis de publicidade, online e offline, na receita. Para isso foi utilizado a análise descritiva e a técnica de análise de regressão múltipla.

# **4. Materiais e Métodos**

A base de dados foi extraída do pacote Robyn, um pacote no R voltado para análises estatísticas para o mercado de publicidade criado pelo Facebook.

O arquivo conta com uma amostra de 208 observações semanais, uma variável data, uma variável dependente e 10 variáveis independentes.

## **4.1 Dicionário de Dados**

DATE = Data (por semana)

revenue = Receita

tv_S = Valor gasto com publicidade na TV

ooh_S = Valor gasto com publicidade Out of Home (Outdoors, pôsteres, painéis digitais, mídia aérea)

print_S = Valor gasto com publicidade impressa (Panfletos)

facebook_I = Impressões no Facebook

search_clicks_P = Cliques em anúncios nos mecanismos de busca (Google, Bing)

search_S = Valor gasto com publiciddade nos mecanismos de busca (Google, Bing)

competitor_sales_B = Vendas do concorrente

facebook_S = Valor gasto com publicidade no Facebook

events = Eventos ocorridos durante determinada semana

newsletter = Impressões no canal de notícias

```{r echo=TRUE}
df = read.csv("Marketing_regressao.csv")
head(df)
```

# **5. Resultados e Discussão**

## **5.1 Análise Descritiva**

### Sumário

Analisando o sumário já temos noção do tipo de dados que precisaremos trabalhar, segue abaixo um resumo:

Variáveis qualitativas: 2

Variáveis quantitativas: 10

Dessas 12 variáveis uma é a variável dependente.

```{r echo=TRUE}
as.data.frame(summary(df))
```

### Normalidade

A análise gráfico e shapiro wilk teste nos mostra um padrão não normal em todas as variáveis, algumas mais e outras menos.

O boxplot abaixo deixa mostra muitos outliers e a mediana sempre com determinado desvio, as variáveis mais próximas da normalidade são "revenue" e "competitor_sales_B".

```{r echo=TRUE}
par(mfrow=c(1,3))
boxplot(df$revenue, ylab="Revenue")
boxplot(df$tv_S, ylab="tv_S")
boxplot(df$ooh_S, ylab="ooh_S")
boxplot(df$facebook_I, ylab="facebook_I")
boxplot(df$search_clicks_P, ylab="search_clicks_P")
boxplot(df$search_S, ylab="search_S")
boxplot(df$competitor_sales_B, ylab="competitor_sales_B")
boxplot(df$facebook_S, ylab="facebook_S")
boxplot(df$newsletter, ylab="newsletter")
```

Já o QQPLOT e QQLINE apresenta desvio dos pontos da linha de tendência, indicando possível anormalidade na distribuição dos dados.

```{r echo=TRUE}
par(mfrow=c(1,3))
qqnorm(df$revenue, ylab="Revenue"); qqline(df$revenue, ylab="Revenue")
qqnorm(df$tv_S, ylab="tv_S"); qqline(df$tv_S, ylab="tv_S")
qqnorm(df$ooh_S, ylab="ooh_S"); qqline(df$ooh_S, ylab="ooh_S")
qqnorm(df$facebook_I, ylab="facebook_I"); qqline(df$facebook_I, ylab="facebook_I")
qqnorm(df$search_clicks_P, ylab="search_clicks_P"); qqline(df$search_clicks_P, ylab="search_clicks_P")
qqnorm(df$search_S, ylab="search_S"); qqline(df$search_S, ylab="search_S")
qqnorm(df$competitor_sales_B, ylab="competitor_sales_B"); qqline(df$competitor_sales_B, ylab="competitor_sales_B")
qqnorm(df$facebook_S, ylab="facebook_S"); qqline(df$facebook_S, ylab="facebook_S")
qqnorm(df$newsletter, ylab="newsletter"); qqline(df$newsletter, ylab="newsletter")
```

E para confirmar a distribuição não-normal o shapiro-wilk teste rejeita a hipótese nula em todas as variáveis.

```{r echo=TRUE}
df_shap = data.frame(Var = c("0"), P_value = c(0))
for (variable in colnames(subset(df, select = -c(DATE, events)))) {
  df_shap[nrow(df_shap) + 1,] = c(variable, shapiro.test(df[[variable]])[2])
}
df_shap
```

### Correlação

A análise de correlação mostra que todas variáveis tem certa correlação positiva com a variável dependente e não aparenta problemas de multicolinearidade, já que a correlação entre variáveis indepedentes não é muito alta.

```{r echo=TRUE}

corrplot::corrplot(cor(df[, sapply(df, is.numeric)], method = "pearson"), method = 'number', type = 'lower', number.cex = 0.5, col=colorRampPalette(c("red","gray","blue"))(200))
```

### **Ajuste do Modelo**

Inicialmente ajustamos um modelo apenas com as variáveis de valor gasto com publicidade para cada canal apenas para ter uma noção do que podemos encontrar.

O modelo retornou significância para todas variáveis, porém pouco explica a variação da variável dependente com R² de 0.43.

```{r echo=TRUE}
modelo = lm(revenue ~ tv_S + ooh_S + print_S + search_S + facebook_S, data = df)
summary(modelo)
anova(modelo)
```

### Seleção de Modelo (Método Forward)

Para a seleção do modelo utilizamos o método forward, tanto AIC como BIC.

```{r echo=TRUE}

modelo1 = lm(revenue ~ 1, data = df)
```

O modelo AIC e BIC foram bem parecidos com exceção da variável facebook_S que foi retirada pelo modelo BIC.

Considerando que a variável facebook_S tinha um valor p maior que 0.10 no modelo AIC faz sentido dizer que o modelo Forward BIC fez a melhor seleção de variáveis.

Modelo final = lm(formula = revenue \~ competitor_sales_B + tv_S + print_S, data = df)

```{r echo=TRUE}
modelo_stepForward_AIC = step(modelo1, scope = ~tv_S + ooh_S + print_S + facebook_I + search_clicks_P + search_S + competitor_sales_B + facebook_S + newsletter, direction = 'forward', k = 2)

n = nrow(df)
modelo_stepForward_BIC = step(modelo1, scope = ~tv_S + ooh_S + print_S + facebook_I + search_clicks_P + search_S + competitor_sales_B + facebook_S + newsletter, direction = 'forward', k = log(n))
```

```{r echo=TRUE}
summary(modelo_stepForward_AIC)
summary(modelo_stepForward_BIC)
```

```{r echo=TRUE}
compareCoefs(modelo_stepForward_AIC, modelo_stepForward_BIC)
```

### **Análise de Resíduos**

```{r echo=TRUE}
residuos1 = modelo_stepForward_BIC$residuals
summary(residuos1)
```

```{r echo=TRUE}
preditos1 = predict(modelo_stepForward_BIC)
preditos1 = modelo_stepForward_BIC$fitted.values
```

```{r echo=TRUE}
qqnorm(residuos1) ; qqline(residuos1)
shapiro.test(residuos1)
```

# **6. Conclusão**
